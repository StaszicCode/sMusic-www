#!/usr/bin/python2
# -*- coding: utf-8 -*-
"""
Bardzo minimalny testowy serwer TCP
"""
import socket
import ssl
from base64 import b64decode, b64encode
import json
import re
from inspect import getargspec
from threading import Thread
from smusicwww import logs
from smusicwww import config
from smusicwww import __version__
from sqlalchemy import Integer, Column, String, create_engine, DateTime
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
import datetime

UNAUTHORIZED_TYPE = 0
RADIO_TYPE = 1
WWW_TYPE = 2

aktualizacja_last_seen = datetime.timedelta(seconds=5)
msgid = 0
queries = {}
radios_connections = {}
PATTERN_MSG = re.compile("([ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789=+/]*?)\n(.+)?", re.DOTALL)

Base = declarative_base()


class Radio(Base):
    __tablename__ = 'radio'
    id = Column(Integer(), primary_key=True)
    name = Column(String(80), unique=True)
    access_key = Column(String(32), unique=True)
    last_seen = Column(DateTime())

# From writeonly.wordpress.com/2009/07/16/simple-read-only-sqlalchemy-sessions/
# Based on code by Yannick Gingras


def abort_ro(*args,**kwargs):
    ''' the terrible consequences for trying
        to flush to the db '''
    print "No writing allowed, tsk!  We're telling mom!"
    return


def db_setup(connstring='sqlite:///:memory:',
               echo=False, readonly=True):
    engine = create_engine(connstring, echo=echo)
    Session = sessionmaker(bind=engine, autoflush=False, autocommit=False)
    session = Session()
    if readonly:
        session.flush = abort_ro   # now it won't flush!

    return session, engine

# end from riteonly.wordpress.com/2009/07/16/simple-read-only-sqlalchemy-sessions/

session, engine = db_setup(config.database_uri, readonly=False)


class Binder():
    def __init__(self):
        self.binds = {}

    def bind(self, function):
        argspec = getargspec(function)
        args = argspec[0]
        if argspec[-1]:
            req_args = args[:len(argspec[-1])-1]
        else:
            req_args = args
        self.binds[function.__name__] = {
            "target": function,
            "reqired_args": req_args,
            "args": args
        }
        return function

radio_comm = Binder()
www_comm = Binder()


def escape(msg):
    return "\t"+b64encode(msg)+"\n"


def un_escape(msg):
    return b64decode(msg)


def ok(conn, addr, type, version, key=None):
    if version != __version__:
        conn.send(escape(json.dumps({u"request": u"error",
                                     u"type": u"incompatibleVersions",
                                     u"cat": u"=^..^=",
                                     u"comment": u"Niekompatybilne wersje komponentow systemu."})))
        return UNAUTHORIZED_TYPE, None
    if type == "radio":
        radio = session.query(Radio).filter_by(access_key=key).first()
        if radio is not None:
            radios_connections[radio.id] = conn
            logs.print_debug("%s:%s został zarejestrowany jako RADIO o id=%s" % (addr[0], addr[1], str(radio.id)))
            return RADIO_TYPE, radio
        else:
            conn.send(escape(json.dumps({u"request": u"error",
                                         u"type": u"wrongKey",
                                         u"cat": u"=^..^=",
                                         u"comment": u"Podany klucz radia jest bledny"})))
            return UNAUTHORIZED_TYPE, None
    if type == "www" and addr[0] == "127.0.0.1":
        logs.print_debug("%s:%s został zarejestrowany jako WWW" % addr)
        return WWW_TYPE, None
    return UNAUTHORIZED_TYPE, None


class ClientHandler(Thread):
    def __init__(self, conn, addr):
        Thread.__init__(self)
        self.daemon = True
        self.__was_stopped = False
        self.conn = conn
        self.addr = addr
        self.type = UNAUTHORIZED_TYPE
        self.object = None

    def run(self):
        global msgid
        global radios_connections
        logs.print_debug("%s:%s połączył się" % self.addr)
        self.conn.write(escape(json.dumps({"request": "type"})))
        msg = self.conn.read()
        buff = ""
        while msg and not self.__was_stopped and not was_killed:
            buff += msg
            parsed_msg = PATTERN_MSG.findall(buff)
            if len(parsed_msg) == 1 and len(parsed_msg[0]) == 2:
                if self.type == RADIO_TYPE:
                    if self.object.last_seen is None or self.object.last_seen + aktualizacja_last_seen < datetime.datetime.now():
                        self.object.last_seen = datetime.datetime.now()
                        print self.object.last_seen
                        session.add(self.object)
                        session.commit()
                buff = parsed_msg[0][1]
                esc_string = parsed_msg[0][0]
                try:
                    data = json.loads(un_escape(esc_string))
                    logs.print_debug("%s:%s: %s" % (self.addr[0], self.addr[1], data))
                    if "request" in data:
                        if self.type == WWW_TYPE:
                            if "radio" in data:
                                if data["radio"] == -1:
                                    datacpy = dict(data)
                                    send_response = datacpy["request"] != "ok"
                                    del datacpy["request"]
                                    ret = www_comm.binds[data["request"]]["target"](**datacpy)
                                    if send_response:
                                        self.conn.send(escape(json.dumps(ret)))
                                else:
                                    msgid += 1
                                    datacpy = dict(data)
                                    datacpy["msgid"] = msgid
                                    del datacpy["radio"]
                                    queries[msgid] = self.conn
                                    if data["radio"] in radios_connections:
                                        radio = radios_connections[data["radio"]]
                                        radio.write(escape(json.dumps(datacpy)))
                                    else:
                                        self.conn.send(escape(json.dumps({u"request": u"error",
                                                                          u"type": u"radioNotConnected",
                                                                          u"cat": u"=^..^=",
                                                                          u"comment": u"Radio o id %s nie jest podlaczone" % data["radio"]})))
                            else:
                                self.conn.send(escape(json.dumps({u"request": u"error",
                                                                  u"type": u"missingParameter",
                                                                  u"parameter": u"radio",
                                                                  u"cat": u"=^..^=",
                                                                  u"comment": u"Brakuje patametrus radio"})))
                        elif self.type == RADIO_TYPE:
                            if "msgid" not in data:
                                datacpy = dict(data)
                                target = radio_comm.binds[datacpy["request"]]["target"]
                                send_response = datacpy["request"] != "ok"
                                del datacpy["request"]
                                ret = target(self.conn, self.addr, **datacpy)
                                if send_response:
                                    self.conn.send(escape(json.dumps(ret)))
                            else:
                                datacpy = dict(data)
                                c = queries[datacpy["msgid"]]
                                del queries[datacpy["msgid"]]
                                del datacpy["msgid"]
                                c.write(escape(json.dumps(datacpy)))
                        elif data["request"] == "ok":
                            datacpy = dict(data)
                            del datacpy["request"]
                            self.type, self.object = ok(self.conn, self.addr, **datacpy)

                except ValueError as e:
                    print [un_escape(esc_string)]
                    print e

            msg = self.conn.read()
        self.conn.close()
        if self.type == RADIO_TYPE:
            radios_connections = {key: value for key, value in radios_connections.items()
                                  if value is not self.conn}
        logs.print_debug("%s:%s rozłączył się" % self.addr)

    def stop(self):
        self.__was_stopped = True


def main():
    global was_killed
    bind_socket = socket.socket()
    bind_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    bind_socket.bind((config.listen_host, config.listen_port))
    logs.print_info("Nasłuchiwanie na {}:{}".format(config.listen_host, config.listen_port))
    bind_socket.listen(5)
    try:
        while True:
            new_socket, from_addr = bind_socket.accept()
            try:
                conn = ssl.wrap_socket(new_socket,
                                       server_side=True,
                                       certfile=config.ssl_cert_file,
                                       keyfile=config.ssl_key_file)

                handler = ClientHandler(conn, from_addr)
                handler.start()
            except ssl.SSLError:
                pass

    except KeyboardInterrupt:
        was_killed = True
        bind_socket.shutdown(socket.SHUT_RDWR)
        bind_socket.close()


if __name__ == "__main__":
    logs.setup_logging()
    logs.print_info("\n+---------------------------------------------+\n|" +
          ("sMusic-www/sMusicServer v{}".format(__version__).center(45, " "))+"|\n|" +
          "https://github.com/mRokita/sMusic-www".center(45, " ") +
          "|\n+---------------------------------------------+\n")
    was_killed = False
    main()
