#!/usr/bin/python2
# -*- coding: utf-8 -*-
"""
Bardzo minimalny testowy serwer TCP
"""
import socket
import ssl
from base64 import b64decode, b64encode
import json
import re
from inspect import getargspec
from threading import Thread
from smusicwww import logs
from smusicwww import config
from smusicwww import __version__
from sqlalchemy import Integer, Column, String, create_engine, DateTime
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
import datetime

UNAUTHORIZED_TYPE = 0
RADIO_TYPE = 1
WWW_TYPE = 2

aktualizacja_last_seen = datetime.timedelta(seconds=5)
msgid = 0
queries = {}
radios_connections = {}
PATTERN_MSG = re.compile("([ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789=+/]*?)\n(.+)?", re.DOTALL)

Base = declarative_base()


class Radio(Base):
    __tablename__ = 'radio'
    id = Column(Integer(), primary_key=True)
    name = Column(String(80), unique=True)
    access_key = Column(String(32), unique=True)
    last_seen = Column(DateTime())


# From writeonly.wordpress.com/2009/07/16/simple-read-only-sqlalchemy-sessions/
# Based on code by Yannick Gingras


def abort_ro(*args, **kwargs):
    ''' the terrible consequences for trying
        to flush to the db '''
    print "No writing allowed, tsk!  We're telling mom!"
    return


def db_setup(connstring='sqlite:///:memory:',
             echo=False, readonly=True):
    engine = create_engine(connstring, echo=echo)
    Session = sessionmaker(bind=engine, autoflush=False, autocommit=False)
    session = Session()
    if readonly:
        session.flush = abort_ro  # now it won't flush!

    return session, engine


# end from riteonly.wordpress.com/2009/07/16/simple-read-only-sqlalchemy-sessions/

session, engine = db_setup(config.database_uri, readonly=False)


class Binder():
    def __init__(self):
        self.binds = {}

    def bind(self, function):
        argspec = getargspec(function)
        args = argspec[0]
        if argspec[-1]:
            req_args = args[:len(argspec[-1]) - 1]
        else:
            req_args = args
        self.binds[function.__name__] = {
            "target": function,
            "reqired_args": req_args,
            "args": args
        }
        return function


radio_comm = Binder()
www_comm = Binder()


def escape(msg):
    return "\t" + b64encode(msg) + "\n"


def un_escape(msg):
    return b64decode(msg)


def error_formater(e_type, comment, other=None):
    if other is None:
        other = {}
    ret = {u"request": u"error",
           u"type": e_type,
           u"cat": u"=^..^=",
           u"comment": comment}
    ret.update(other)
    return ret


class ClientHandler(Thread):
    def __init__(self, conn, addr):
        Thread.__init__(self)
        self.daemon = True
        self.__was_stopped = False
        self.conn = conn
        self.addr = addr
        self.type = UNAUTHORIZED_TYPE
        self.object = None
        self.id = -1

    def run(self):
        global radios_connections
        logs.print_debug("%s:%s połączył się" % self.addr)
        self.conn.write(escape(json.dumps({"request": "type"})))
        msg = self.conn.read()
        buff = ""
        while msg and not self.__was_stopped and not was_killed:
            buff += msg
            if '\n' in msg:
                esc_string = buff[:buff.index('\n')]
                buff = buff[buff.index('\n') + 1:]
                if self.type == RADIO_TYPE:
                    if self.object.last_seen is None or self.object.last_seen + aktualizacja_last_seen < datetime.datetime.now():
                        self.object.last_seen = datetime.datetime.now()
                        print self.object.last_seen
                        session.add(self.object)
                        session.commit()
                try:
                    data = json.loads(un_escape(esc_string))
                    logs.print_debug("%s:%s: %s" % (self.addr[0], self.addr[1], data))
                    if "request" in data:
                        if self.type == WWW_TYPE:
                            if "radio" in data:
                                if data["radio"] == -1:
                                    datacpy = dict(data)
                                    send_response = datacpy["request"] != "ok"
                                    del datacpy["request"]
                                    ret = www_comm.binds[data["request"]]["target"](**datacpy)
                                    if send_response:
                                        self.send_request(ret)
                                else:
                                    if data["radio"] in radios_connections:
                                        radio = radios_connections[data["radio"]]
                                        del data["radio"]
                                        radio.send_request(data, self.send_request)
                                    else:
                                        self.send_request(error_formater(u"radioNotConnected", u"Radio o id %s nie jest podlaczone" % data["radio"]))
                            else:
                                self.send_request(error_formater(u"missingParameter", u"Brakuje patametrus radio", {u"parameter": u"radio"}))
                        elif self.type == RADIO_TYPE:
                            if "msgid" not in data:
                                datacpy = dict(data)
                                target = radio_comm.binds[datacpy["request"]]["target"]
                                send_response = datacpy["request"] != "ok"
                                del datacpy["request"]
                                ret = target(self.conn, self.addr, **datacpy)
                                if send_response:
                                    self.send_request(ret)
                            else:
                                datacpy = dict(data)
                                back_ref = queries[datacpy["msgid"]]
                                del queries[datacpy["msgid"]]
                                del datacpy["msgid"]
                                back_ref(datacpy)
                        elif data["request"] == "ok":
                            datacpy = dict(data)
                            del datacpy["request"]
                            self.type, self.object = self.authenticate(**datacpy)

                except ValueError as e:
                    print [un_escape(esc_string)]
                    print e

            msg = self.conn.read()
        self.conn.close()
        if self.type == RADIO_TYPE:
            del radios_connections[self.id]
        logs.print_debug("%s:%s rozłączył się" % self.addr)

    def authenticate(self, type, version, key=None):
        if version != __version__:
            self.send_request(error_formater(u"incompatibleVersions", u"Niekompatybilne wersje komponentow systemu."))
            return UNAUTHORIZED_TYPE, None
        if type == "radio":
            radio = session.query(Radio).filter_by(access_key=key).first()
            if radio is not None:
                radios_connections[radio.id] = self
                self.id = radio.id
                logs.print_debug(
                    "%s:%s został zarejestrowany jako RADIO o id=%s" % (self.addr[0], self.addr[1], str(radio.id)))
                return RADIO_TYPE, radio
            else:
                self.send_request(error_formater(u"wrongKey", u"Podany klucz radia jest bledny"))
                return UNAUTHORIZED_TYPE, None
        if type == "www" and self.addr[0] == "127.0.0.1":
            logs.print_debug("%s:%s został zarejestrowany jako WWW" % self.addr)
            return WWW_TYPE, None
        return UNAUTHORIZED_TYPE, None

    def stop(self):
        self.__was_stopped = True

    def send_request(self, req, back_ref=None):
        global msgid
        print req
        reqcpy = dict(req)
        if req["request"] not in ["ok", "error"] and back_ref is not None:
            reqcpy["msgid"] = msgid
            queries[msgid] = back_ref
            msgid += 1
        try:
            self.conn.send(escape(json.dumps(reqcpy)))
        except socket.error, exc:
            print "Caught exception socket.error : %s" % exc
            if back_ref is not None:
                back_ref(error_formater(u"connectionError", u"socket.error exception - %s" % exc))


def main():
    global was_killed
    bind_socket = socket.socket()
    bind_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    bind_socket.bind((config.listen_host, config.listen_port))
    logs.print_info("Nasłuchiwanie na {}:{}".format(config.listen_host, config.listen_port))
    bind_socket.listen(5)
    try:
        while True:
            new_socket, from_addr = bind_socket.accept()
            try:
                conn = ssl.wrap_socket(new_socket,
                                       server_side=True,
                                       certfile=config.ssl_cert_file,
                                       keyfile=config.ssl_key_file)

                handler = ClientHandler(conn, from_addr)
                handler.start()
            except ssl.SSLError:
                pass

    except KeyboardInterrupt:
        was_killed = True
        bind_socket.shutdown(socket.SHUT_RDWR)
        bind_socket.close()


if __name__ == "__main__":
    logs.setup_logging()
    logs.print_info("\n+---------------------------------------------+\n|" +
                    ("sMusic-www/sMusicServer v{}".format(__version__).center(45, " ")) + "|\n|" +
                    "https://github.com/mRokita/sMusic-www".center(45, " ") +
                    "|\n+---------------------------------------------+\n")
    was_killed = False
    main()
