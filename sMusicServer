#!/usr/bin/python2
# -*- coding: utf-8 -*-
"""
Bardzo minimalny testowy serwer TCP
"""
import socket
import ssl
from base64 import b64decode, b64encode
import json
import re
from inspect import getargspec
from threading import Thread
from smusicwww import logs
from smusicwww import config
from smusicwww import __version__
from sqlalchemy import Integer, Column, String, create_engine, DateTime
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
import datetime
import time

UNAUTHORIZED_TYPE = 0
RADIO_TYPE = 1
WWW_TYPE = 2

aktualizacja_last_seen = datetime.timedelta(seconds=5)
timeout_time = datetime.timedelta(seconds=30)
ping_frequency = datetime.timedelta(seconds=5)

msgid = 0
queries = {}
radios_connections = {}
PATTERN_MSG = re.compile("([ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789=+/]*?)\n(.+)?", re.DOTALL)

Base = declarative_base()


class Radio(Base):
    __tablename__ = 'radio'
    id = Column(Integer(), primary_key=True)
    name = Column(String(80), unique=True)
    access_key = Column(String(32), unique=True)
    last_seen = Column(DateTime())


# From writeonly.wordpress.com/2009/07/16/simple-read-only-sqlalchemy-sessions/
# Based on code by Yannick Gingras


def abort_ro(*args, **kwargs):
    ''' the terrible consequences for trying
        to flush to the db '''
    print "No writing allowed, tsk!  We're telling mom!"
    return


def db_setup(connstring='sqlite:///:memory:',
             echo=False, readonly=True):
    engine = create_engine(connstring, echo=echo)
    Session = sessionmaker(bind=engine, autoflush=False, autocommit=False)
    session = Session()
    if readonly:
        session.flush = abort_ro  # now it won't flush!

    return session, engine


# end from riteonly.wordpress.com/2009/07/16/simple-read-only-sqlalchemy-sessions/

session, engine = db_setup(config.database_uri, readonly=False)


class Binder():
    def __init__(self):
        self.binds = {}

    def bind(self):
        def bind(function):
            argspec = getargspec(function)
            args = argspec[0]
            if argspec[-1]:
                req_args = args[:len(argspec[-1]) - 1]
            else:
                req_args = args
            self.binds[function.__name__] = {
                "target": function,
                "reqired_args": req_args,
                "args": args
            }
            return function
        return bind


radio_comm = Binder()
www_comm = Binder()


@radio_comm.bind()
def ok(conn, addr):
    pass


@www_comm.bind()
def list_connected():
    return {"request": "ok", "radios_list": radios_connections.keys()}


def escape(msg):
    return "\t" + b64encode(msg) + "\n"


def un_escape(msg):
    return b64decode(msg)


def error_formater(e_type, comment, other=None):
    if other is None:
        other = {}
    ret = {u"request": u"error",
           u"type": e_type,
           u"cat": u"=^..^=",
           u"comment": comment}
    ret.update(other)
    return ret


class ClientHandler(Thread):
    def __init__(self, conn, addr):
        Thread.__init__(self)
        self.daemon = True
        self.__was_stopped = False
        self.conn = conn
        self.addr = addr
        self.type = UNAUTHORIZED_TYPE
        self.object = None
        self.id = -1

    def run(self):
        global radios_connections
        logs.print_debug("%s:%s połączył się" % self.addr)
        self.conn.write(escape(json.dumps({"request": "type"})))
        msg = self.conn.read()
        buff = ""
        while msg and not self.__was_stopped and not was_killed:
            buff += msg
            if '\n' in msg:
                esc_string = buff[:buff.index('\n')]
                buff = buff[buff.index('\n') + 1:]
                if self.type == RADIO_TYPE:
                    self.__renew_last_seen()
                try:
                    data = json.loads(un_escape(esc_string))
                    logs.print_debug("%s:%s: %s" % (self.addr[0], self.addr[1], data))
                    if "request" in data:
                        if self.type == WWW_TYPE:
                            if "radio" in data:
                                if data["radio"] == -1:
                                    datacpy = dict(data)
                                    send_response = datacpy["request"] != "ok"
                                    del datacpy["request"]
                                    del datacpy["radio"]
                                    ret = www_comm.binds[data["request"]]["target"](**datacpy)
                                    if send_response:
                                        self.send_request(ret)
                                else:
                                    if data["radio"] in radios_connections:
                                        radio = radios_connections[data["radio"]]
                                        del data["radio"]
                                        radio.send_request(data, self.send_request)
                                    else:
                                        self.send_request(error_formater(u"radioNotConnected", u"Radio o id %s nie jest podlaczone" % data["radio"]))
                            else:
                                self.send_request(error_formater(u"missingParameter", u"Brakuje patametrus radio", {u"parameter": u"radio"}))
                        elif self.type == RADIO_TYPE:
                            if "msgid" not in data:
                                datacpy = dict(data)
                                target = radio_comm.binds[datacpy["request"]]["target"]
                                send_response = datacpy["request"] != "ok"
                                del datacpy["request"]
                                ret = target(self.conn, self.addr, **datacpy)
                                if send_response:
                                    self.send_request(ret)
                            else:
                                datacpy = dict(data)
                                back_ref = queries[datacpy["msgid"]]
                                del queries[datacpy["msgid"]]
                                del datacpy["msgid"]
                                back_ref(datacpy)
                        elif data["request"] == "ok":
                            datacpy = dict(data)
                            del datacpy["request"]
                            self.authenticate(**datacpy)

                except ValueError as e:
                    print [un_escape(esc_string)]
                    print e
            try:
                msg = self.conn.read()
            except (socket.error, ValueError) as e:
                if not self.__was_stopped:
                    logs.print_warning("%s:%s - socket.error: %s" % (self.addr + (str(e),)))
                    self.stop()
        if self.type == RADIO_TYPE:
            del radios_connections[self.id]
        logs.print_debug("%s:%s zakończone obsługę klienta" % self.addr)
        self.stop()

    def authenticate(self, type, version, key=None):
        if version != __version__:
            self.send_request(error_formater(u"incompatibleVersions", u"Niekompatybilne wersje komponentow systemu."))
            self.type = UNAUTHORIZED_TYPE
            self.object = None
        if type == "radio":
            radio = session.query(Radio).filter_by(access_key=key).first()
            if radio is not None:
                radios_connections[radio.id] = self
                self.id = radio.id
                logs.print_debug(
                    "%s:%s został zarejestrowany jako RADIO o id=%s" % (self.addr[0], self.addr[1], str(radio.id)))
                self.type = RADIO_TYPE
                self.object = radio
                self.__renew_last_seen()
                Thread(target=self.__pinger).start()
            else:
                self.send_request(error_formater(u"wrongKey", u"Podany klucz radia jest bledny"))
        if type == "www" and self.addr[0] == "127.0.0.1":
            logs.print_debug("%s:%s został zarejestrowany jako WWW" % self.addr)
            self.type = WWW_TYPE
            self.object = None

    def stop(self):
        logs.print_debug("%s:%s rozłączanie klienta" % self.addr)
        self.__was_stopped = True
        self.conn.close()

    def send_request(self, req, back_ref=None):
        global msgid
        reqcpy = dict(req)
        if req["request"] not in ["ok", "error"] and back_ref is not None:
            reqcpy["msgid"] = msgid
            queries[msgid] = back_ref
            msgid += 1
        try:
            self.conn.send(escape(json.dumps(reqcpy)))
        except socket.error, exc:
            print "Caught exception socket.error : %s" % exc
            if back_ref is not None:
                back_ref(error_formater(u"connectionError", u"socket.error exception - %s" % exc))

    def __pinger(self):
        while not self.__was_stopped:
            if datetime.datetime.now() - self.object.last_seen > timeout_time:
                logs.print_debug("%s:%s przekroczyl czas oczekiwania na odpowiedz" % self.addr)
                self.stop()
            elif datetime.datetime.now() - self.object.last_seen > ping_frequency:
                self.send_request({"request": "ping"})
            time.sleep(1)

    def __renew_last_seen(self):
        if self.object.last_seen is None or self.object.last_seen + aktualizacja_last_seen < datetime.datetime.now():
            self.object.last_seen = datetime.datetime.now()
            session.add(self.object)
            session.commit()


def main():
    global was_killed
    bind_socket = socket.socket()
    bind_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    bind_socket.bind((config.listen_host, config.listen_port))
    logs.print_info("Nasłuchiwanie na {}:{}".format(config.listen_host, config.listen_port))
    bind_socket.listen(5)
    try:
        while True:
            new_socket, from_addr = bind_socket.accept()
            try:
                conn = ssl.wrap_socket(new_socket,
                                       server_side=True,
                                       certfile=config.ssl_cert_file,
                                       keyfile=config.ssl_key_file)

                handler = ClientHandler(conn, from_addr)
                handler.start()
            except ssl.SSLError:
                pass

    except KeyboardInterrupt:
        was_killed = True
        bind_socket.shutdown(socket.SHUT_RDWR)
        bind_socket.close()


if __name__ == "__main__":
    logs.setup_logging()
    logs.print_info("\n+---------------------------------------------+\n|" +
                    ("sMusic-www/sMusicServer v{}".format(__version__).center(45, " ")) + "|\n|" +
                    "https://github.com/mRokita/sMusic-www".center(45, " ") +
                    "|\n+---------------------------------------------+\n")
    was_killed = False
    main()
